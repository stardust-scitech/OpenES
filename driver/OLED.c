/**
  ******************************************************************************
  * @file    OLED.c
  * @brief   This file provides all the business logic functions.
  * @author  Kevin Brooks
  * @version 1.0
  * @date    2019_12_29
  * @email   kevin@stardust.live
  * @license Copyright (C) 2018, Stardust Studio,  All Rights Reserved
  ******************************************************************************
  */

#include "OLED.h"
#include "system.h"
#include <stdlib.h> //function abs
#include <string.h> //memset
#include <stdio.h> //memset

#include "i2c_master.h"

u8 OLED_GRAM[128][8];

u8 G_X_Pointer, G_Y_Pointer;

/************************************6*8 lattice************************************/
const unsigned char F6x8[][6] =		
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// sp
	0x00, 0x00, 0x00, 0x2f, 0x00, 0x00,// !
	0x00, 0x00, 0x07, 0x00, 0x07, 0x00,// "
	0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14,// #
	0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12,// $
	0x00, 0x62, 0x64, 0x08, 0x13, 0x23,// %
	0x00, 0x36, 0x49, 0x55, 0x22, 0x50,// &
	0x00, 0x00, 0x05, 0x03, 0x00, 0x00,// '
	0x00, 0x00, 0x1c, 0x22, 0x41, 0x00,// (
	0x00, 0x00, 0x41, 0x22, 0x1c, 0x00,// )
	0x00, 0x14, 0x08, 0x3E, 0x08, 0x14,// *
	0x00, 0x08, 0x08, 0x3E, 0x08, 0x08,// +
	0x00, 0x00, 0x00, 0xA0, 0x60, 0x00,// ,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08,// -
	0x00, 0x00, 0x60, 0x60, 0x00, 0x00,// .
	0x00, 0x20, 0x10, 0x08, 0x04, 0x02,// /
	0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
	0x00, 0x00, 0x42, 0x7F, 0x40, 0x00,// 1
	0x00, 0x42, 0x61, 0x51, 0x49, 0x46,// 2
	0x00, 0x21, 0x41, 0x45, 0x4B, 0x31,// 3
	0x00, 0x18, 0x14, 0x12, 0x7F, 0x10,// 4
	0x00, 0x27, 0x45, 0x45, 0x45, 0x39,// 5
	0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
	0x00, 0x01, 0x71, 0x09, 0x05, 0x03,// 7
	0x00, 0x36, 0x49, 0x49, 0x49, 0x36,// 8
	0x00, 0x06, 0x49, 0x49, 0x29, 0x1E,// 9
	0x00, 0x00, 0x36, 0x36, 0x00, 0x00,// :
	0x00, 0x00, 0x56, 0x36, 0x00, 0x00,// ;
	0x00, 0x08, 0x14, 0x22, 0x41, 0x00,// <
	0x00, 0x14, 0x14, 0x14, 0x14, 0x14,// =
	0x00, 0x00, 0x41, 0x22, 0x14, 0x08,// >
	0x00, 0x02, 0x01, 0x51, 0x09, 0x06,// ?
	0x00, 0x32, 0x49, 0x59, 0x51, 0x3E,// @
	0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C,// A
	0x00, 0x7F, 0x49, 0x49, 0x49, 0x36,// B
	0x00, 0x3E, 0x41, 0x41, 0x41, 0x22,// C
	0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C,// D
	0x00, 0x7F, 0x49, 0x49, 0x49, 0x41,// E
	0x00, 0x7F, 0x09, 0x09, 0x09, 0x01,// F
	0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A,// G
	0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F,// H
	0x00, 0x00, 0x41, 0x7F, 0x41, 0x00,// I
	0x00, 0x20, 0x40, 0x41, 0x3F, 0x01,// J
	0x00, 0x7F, 0x08, 0x14, 0x22, 0x41,// K
	0x00, 0x7F, 0x40, 0x40, 0x40, 0x40,// L
	0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F,// M
	0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F,// N
	0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E,// O
	0x00, 0x7F, 0x09, 0x09, 0x09, 0x06,// P
	0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
	0x00, 0x7F, 0x09, 0x19, 0x29, 0x46,// R
	0x00, 0x46, 0x49, 0x49, 0x49, 0x31,// S
	0x00, 0x01, 0x01, 0x7F, 0x01, 0x01,// T
	0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F,// U
	0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F,// V
	0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F,// W
	0x00, 0x63, 0x14, 0x08, 0x14, 0x63,// X
	0x00, 0x07, 0x08, 0x70, 0x08, 0x07,// Y
	0x00, 0x61, 0x51, 0x49, 0x45, 0x43,// Z
	0x00, 0x00, 0x7F, 0x41, 0x41, 0x00,// [
	0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55,// 55
	0x00, 0x00, 0x41, 0x41, 0x7F, 0x00,// ]
	0x00, 0x04, 0x02, 0x01, 0x02, 0x04,// ^
	0x00, 0x40, 0x40, 0x40, 0x40, 0x40,// _
	0x00, 0x00, 0x01, 0x02, 0x04, 0x00,// '
	0x00, 0x20, 0x54, 0x54, 0x54, 0x78,// a
	0x00, 0x7F, 0x48, 0x44, 0x44, 0x38,// b
	0x00, 0x38, 0x44, 0x44, 0x44, 0x20,// c
	0x00, 0x38, 0x44, 0x44, 0x48, 0x7F,// d
	0x00, 0x38, 0x54, 0x54, 0x54, 0x18,// e
	0x00, 0x08, 0x7E, 0x09, 0x01, 0x02,// f
	0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C,// g
	0x00, 0x7F, 0x08, 0x04, 0x04, 0x78,// h
	0x00, 0x00, 0x44, 0x7D, 0x40, 0x00,// i
	0x00, 0x40, 0x80, 0x84, 0x7D, 0x00,// j
	0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,// k
	0x00, 0x00, 0x41, 0x7F, 0x40, 0x00,// l
	0x00, 0x7C, 0x04, 0x18, 0x04, 0x78,// m
	0x00, 0x7C, 0x08, 0x04, 0x04, 0x78,// n
	0x00, 0x38, 0x44, 0x44, 0x44, 0x38,// o
	0x00, 0xFC, 0x24, 0x24, 0x24, 0x18,// p
	0x00, 0x18, 0x24, 0x24, 0x18, 0xFC,// q
	0x00, 0x7C, 0x08, 0x04, 0x04, 0x08,// r
	0x00, 0x48, 0x54, 0x54, 0x54, 0x20,// s
	0x00, 0x04, 0x3F, 0x44, 0x40, 0x20,// t
	0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C,// u
	0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C,// v
	0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C,// w
	0x00, 0x44, 0x28, 0x10, 0x28, 0x44,// x
	0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C,// y
	0x00, 0x44, 0x64, 0x54, 0x4C, 0x44,// z
	0x14, 0x14, 0x14, 0x14, 0x14, 0x14,// horiz lines
};
/****************************************8*16 lattice************************************/
const unsigned char F8X16[] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0
	0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//! 1
	0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//" 2
	0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//# 3
	0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$ 4
	0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//% 5
	0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//& 6
	0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//' 7
	0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//( 8
	0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//) 9
	0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//* 10
	0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+ 11
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//, 12
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//- 13
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//. 14
	0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,/// 15
	0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//0 16
	0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//1 17
	0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//2 18
	0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//3 19
	0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//4 20
	0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//5 21
	0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//6 22
	0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//7 23
	0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//8 24
	0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//9 25
	0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//: 26
	0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//; 27
	0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//< 28
	0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,//= 29
	0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//> 30
	0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//? 31
	0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@ 32
	0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A 33
	0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B 34
	0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C 35
	0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D 36
	0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E 37
	0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F 38
	0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G 39
	0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H 40
	0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I 41
	0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J 42
	0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K 43
	0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L 44
	0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M 45
	0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N 46
	0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O 47
	0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P 48
	0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q 49
	0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R 50
	0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S 51
	0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T 52
	0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U 53
	0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V 54
	0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W 55
	0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X 56
	0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y 57
	0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z 58
	0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[ 59
	0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\ 60
	0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//] 61
	0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^ 62
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_ 63
	0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//` 64
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a 65
	0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b 66
	0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c 67
	0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d 68
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e 69
	0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f 70
	0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g 71
	0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h 72
	0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i 73
	0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j 74
	0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k 75
	0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l 76
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m 77
	0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n 78
	0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o 79
	0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p 80
	0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q 81
	0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r 82
	0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s 83
	0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t 84
	0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u 85
	0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v 86
	0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w 87
	0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x 88
	0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y 89
	0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z 90
	0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{ 91
	0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//| 92
	0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//} 93
	0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~ 94
};

const unsigned char BMP1[] = {};

const unsigned char F16x16[] = {};

/**
  * @brief I2C_WriteByte function
  * @param addr I2C address
  * @param data I2C data to write 
  * @return void
  */
static void I2C_WriteByte(uint8_t addr,uint8_t data)
{
	i2c_master_start();
	
	i2c_master_writeByte(OLED_ADDRESS);

	if(!i2c_master_checkAck())
	{
		i2c_master_stop();
		//return 0;
	}


	i2c_master_writeByte(addr);

	if(!i2c_master_checkAck())
	{
		i2c_master_stop();
		//return 0;
	}

	i2c_master_writeByte(data&0xff);

	if(!i2c_master_checkAck())
	{
		i2c_master_stop();
		//return 0;
	}
	//ֹͣiicͨ��
	i2c_master_stop();
	
	//return 1;
}

/**
  * @brief Writing command
  * @param I2C_Command I2C Command
  * @return void
  */
static void WriteCmd(u8 I2C_Command)
{
	I2C_WriteByte(0x00, I2C_Command);
}

/**
  * @brief Writing data
  * @param I2C_Data I2C Data
  * @return void
  */
void WriteDat(u8 I2C_Data, u8 t)
{
#if OLED_DISPLAY_TYPE
	if(t)	OLED_GRAM[G_X_Pointer][G_Y_Pointer] &= ~I2C_Data;
	else 	OLED_GRAM[G_X_Pointer][G_Y_Pointer] |= I2C_Data;
#else
	I2C_WriteByte(0x40, I2C_Data);
#endif
}

/**
  * @brief Set starting point coordinates
  * @param x X coordinates
  * @param y Y coordinates
  * @param t [0 / 1] 0 is empty,1 is fill
  * @return void
  */
void OLED_SetPos(u8 x, u8 y)
{ 
#if OLED_DISPLAY_TYPE
	G_X_Pointer = x;
	G_Y_Pointer = y;
#else
	WriteCmd(0xb0+y);
	WriteCmd(x&0x0f);	//WriteCmd((x&0x0f)|0x01);Will result in a gap display
	WriteCmd(((x&0xf0)>>4)|0x10);
#endif
}

/**
  * @brief OLED init
  * @param void
  * @return void
  */
void OLED_Init(void)
{
	/**********I2C Configuration**********/
	delay_ms(100); //等待屏幕供电正常

	i2c_master_gpio_init();

	/**********CMD Configuration(Reference from SSD1306 DataSheet Aug 2010)**********/
	WriteCmd(0xae); //(display off)
	
	/*(一)基础指令*/	
		WriteCmd(0x81); //(set contrast control register,亮度控制)
		WriteCmd(0xff); //(亮度调节范围:0x00~0xff)
		
		WriteCmd(0xa4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content,a5即白屏,无视RAM内容，用于测试显示屏)
		
		WriteCmd(0xa6); //(set normal display,a7:反相显示,亮的部分变暗，暗的部分变亮)	
		
//		WriteCmd(0xae); //(display off,顶部已开启）
//		WriteCmd(0xaf); //(turn on oled panel,底部已开启)
	/*************/	
	
	/*(二)滚动显示*/
//		WriteCmd(0x26); //(26h:水平右滚 27:水平左滚 29h:Vertical and Right Horizontal Scroll 2ah:Vertical and Left Horizontal Scroll)
//		WriteCmd(0x00); //(固态字节(芯片固定字节,用户不可改动)
//		WriteCmd(0x00); //(滚动起始页)
//		WriteCmd(0x01); //(滚动速度,64 frames)
//		WriteCmd(0x07); //(滚动结束页)
//		WriteCmd(0x00); //(固态字节,如果是29h或2ah(h是16进制数的意思)则取值为0-63)
//		WriteCmd(0xff); //(固态字节,如果是29h或2ah(h是16进制数的意思)则注释这行)
		
//		WriteCmd(0x2e);	//(关闭滚屏)

//		WriteCmd(0x2f);	//(激活滚屏)

//		WriteCmd(0xA3);	//(设置滚屏范围)
//		WriteCmd(0x08);	//(不滚屏的行数)
//		WriteCmd(0x20);	//(要滚屏的行数)
	/*************/
	
	/*(三)地址设置*/
//		WriteCmd(0x00); //(set low column address,初始化设置了没用,因为OLED_SetPos函数中会重设)
//		
//		WriteCmd(0x10); //(set high column address,初始化设置了没用,因为OLED_SetPos函数中会重设)
			
		WriteCmd(0x20);	//(Set Memory Addressing Mode)
		WriteCmd(0x10);	//(00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid)
		
//		WriteCmd(0x21);	//(列(起止)地址)
//		WriteCmd(0x00);	//A[6:0] : Column start address, range : 0-127d,(RESET=0d)
//		WriteCmd(0x7F);	//B[6:0]: Column end address, range : 0-127d,(RESET =127d)
//		
//		WriteCmd(0x21);	//(行(起止)地址)
//		WriteCmd(0x00);	//A[2:0] : Page start Address, range : 0-7d,(RESET = 0d)
//		WriteCmd(0x07);	//B[2:0] : Page end Address, range : 0-7d,(RESET = 7d)
		
//		WriteCmd(0xb0);	//(Set Page Start Address for Page Addressing Mode,0-7,初始化设置了没用,因为OLED_SetPos函数中会重设)
	/*************/

	/*(四)硬件配置*/
		WriteCmd(0x40); //(set start line address,从RAM中哪一行起读取显示内容)
		
		WriteCmd(0xa1); //(set segment re-map 0 to 127,列显示次序反向)A0h, X[0]=0b: column address 0 is mapped to SEG0 (RESET) | A1h, X[0]=1b: column address 127 is mapped to SEG0
		
		WriteCmd(0xa8); //(set multiplex ratio设置只扫描哪些行,可提高帧率)
		WriteCmd(0x3F); //(范围16-63)
		
		WriteCmd(0xc8);	//(Set COM Output Scan Direction,即行扫方向)C0h, X[3]=0b: normal mode (RESET) Scan from COM0 to COM[N –1] | C8h, X[3]=1b: remapped mode. Scan from COM[N-1] to COM0
		
		WriteCmd(0xd3); //(set display offset,行扫偏移,公共极（垂直）方向移动)
		WriteCmd(0x00); //(not offset)
		
		WriteCmd(0xda); //(set com pins hardware configuration,4种组合，再结合行扫方向有8种)
		WriteCmd(0x12);	//(设为默认值)A[4]=1b(RESET), Alternative COM pin configuration | A[5]=0b(RESET), Disable COM Left/Right remap
	/*************/

	/*(五)时序设置*/
		WriteCmd(0xd5); //(set display clock divide ratio/oscillator frequency)
		WriteCmd(0xf0); //(set divide ratio频率设置成最高407 kHz,分频系数为1)	

		WriteCmd(0xd9); //(set pre-charge period,充电、放电周期1-15设置)
		WriteCmd(0x22); //(设置为默认值2DCLK)
		
		WriteCmd(0xdb); //(设置Vcomh电压,防止单元串扰,Vcomh反压)
		WriteCmd(0x20); //(20h ~ 0.77 x VCC (RESET))
	/*************/	
	
	/*(六)高级图形命令*/
//		WriteCmd(0x23);	//(显示屏淡出和闪烁设置)
//		WriteCmd(0x21);	//(Fade Mode & 16 Frames) A[5:4] = 00b Disable Fade Out/Blinking Mode[RESET] | A[5:4] = 10b Enable Fade Out mode | A[5:4] = 11b Enable Blinking mode

//		WriteCmd(0xD6);	//(放大一倍显示,矢量放大)
//		WriteCmd(0x01);	//A[0] = 0b Disable Zoom in Mode[RESET] | A[0] = 1b Enable Zoom in Mode
	/*****************/
	
	/*(七)充电泵设置*/
		WriteCmd(0x8d); //(电荷泵设置,VBAT = 3.3V~4.2V to Charge Pump VCC = 7.0V~7.5V,使oled点亮)
		WriteCmd(0x14); //(使能电荷泵）
		WriteCmd(0xe3);	//(空操作)
	/***************/
	
	WriteCmd(0xaf); //（turn on oled panel)
	
	/**********OLED CLS**********/
	OLED_Fill(0x00);
}

void OLED_BrightnessAdjustment(u8 val)
{
		WriteCmd(0x81); //(set contrast control register,亮度控制)
		WriteCmd(val); //(亮度调节范围:0x00~0xff)
}

void OLED_DisplayAdjustment(OLED_DISPLAY type)
{
		WriteCmd(type+0xa6); //(set normal display,a7:反相显示,亮的部分变暗，暗的部分变亮)	
}

/**
  * @brief Wake OLED from sleep
  * @param void
  * @return void
  */
void OLED_ON(void)
{
	WriteCmd(0X8D); //Set charge pump
	WriteCmd(0X14); //Turn on the charge pump
	WriteCmd(0XAF); //OLED awaken
}

/**
  * @brief Let OLED sleep - in sleep mode, OLED power consumption is less than 10uA
  * @param void
  * @return void
  */
void OLED_OFF(void)
{
	WriteCmd(0X8D); //Set charge pump
	WriteCmd(0X10); //Turn off the charge pump
	WriteCmd(0XAE); //OLED dormancy
}

/**
  * @brief Full screen fill
  * @param fill_Data [0x00-0xFF] Fill data
  * @return void
  */
void OLED_Fill(u8 fill_Data)
{
	u8 m,n;
	for(m=0;m<8;m++)
	{
		WriteCmd(0xb0+m);	//page0-page1
		WriteCmd(0x00);		//low column start address
		WriteCmd(0x10);		//high column start address
		for(n=0;n<128;n++)
		{
			I2C_WriteByte(0x40, fill_Data);
		}
	}
}

void OLED_Refresh_Gram(void)
{
	u8 m,n;
	for(m=0;m<8;m++)
	{
		WriteCmd(0xb0+m);	//page0-page1
		WriteCmd(0x00);		//low column start address
		WriteCmd(0x10);		//high column start address
		for(n=0;n<128;n++)
		{
			I2C_WriteByte(0x40,OLED_GRAM[n][m]);
		}
	}
	
	memset(OLED_GRAM,0,sizeof(OLED_GRAM));
}

/**
  * @brief Clean screen
  * @param void
  * @return void
  */
void OLED_CLS(void)
{
#if OLED_DISPLAY_TYPE
	memset(OLED_GRAM,0,sizeof(OLED_GRAM));
	OLED_Refresh_Gram();
#else
	OLED_Fill(0x00);
#endif
}

/**
  * @brief Display ASCII characters, with 6*8 and 8*16 options
  * @param x X coordinates
  * @param y Y coordinates
  * @param t [0 / 1] 0 is empty,1 is fill
  * @return void
  */
void OLED_DrawPoint(int16_t x,int16_t y,u8 t)
{
	u8 data;  //data1当前点的数据
	if(x<0 || x>127 || y<0 || y>63)return;// 超出范围了 
#if OLED_DISPLAY_TYPE
	data = 0x01<<(y%8);
	if(t)	OLED_GRAM[x][y/8]|=data;
	else 	OLED_GRAM[x][y/8]&=~data;
#else
	OLED_SetPos(x,y/8);
	data = 0x01<<(y%8);
	if(t==0) data=0x00;
	WriteDat(data, t);
#endif
}

void OLED_DrawLine(u8 x,u8 y,u8 t)
{
	u8 data;  //data1当前点的数据
	if(x>127||y>63)return;// 超出范围了 
#if OLED_DISPLAY_TYPE
	data = 0x01<<(y%8);
	if(t)	OLED_GRAM[x][y/8]|=data;
	else 	OLED_GRAM[x][y/8]&=~data;
#else
	OLED_SetPos(x,y/8);
	data = 0x01<<(y%8);
	if(t==0) data=0x00;
	WriteDat(data, t);
#endif
}

/**
  * @brief Display ASCII characters, with 6*8 and 8*16 options
  * @param x X coordinates
  * @param y Y coordinates
  * @return void
  */
void OLED_ShowStr(u8 x, u8 y, u8 ch[], OLED_ALIGNMENT mode, u8 TextSize, OLED_DISPLAY type)
{
	u8 c=0, i=0, j=0, x_initial=0;
	
	//中文判断，目前尚不完美
	if(ch[j] > 127)
	{
		TextSize = 8*16;
	}
	
	switch(TextSize)
	{
		case 6*8:
		{
			if(mode == 1)
			{
				x -= strlen((char*)ch)*6-1;
				x_initial = x;
			}else if(mode == 2)
			{
				x -= strlen((char*)ch)*3;
				x_initial = x;
			}
			while(ch[j] != '\0')
			{
				if(ch[j] == 0x0D)
				{
					if(ch[++j] == 0x0A)
					{
						x = x_initial;
						y ++;
						j++;
					}
				}
				else
				{
					c = ch[j] - 32;
					
					if((x+6) > 128)
					{
						x = 0;
						y++;
					}
					if(y > 7)
					{
						OLED_CLS();
						OLED_ShowStr(0, 0, "String text out of page!", LEFT, 6*8, NORMAL);
						break;
					}
					OLED_SetPos(x,y);
					for(i=0;i<6;i++)
					{
						WriteDat(F6x8[c][i], type);
						G_X_Pointer++;
					}
					x += 6;
					j++;
				}
			}
			break;
		}
		case 8*16:
		{
			u8 len = 0;
			u8* str =  ch;
			
			while(str[j] != '\0')
			{
				if(str[j] == 0x0D)
				{
					if(str[++j] == 0x0A)
					{
						len += 2;
						j++;
					}
				}
				else
				{
					if(str[j] < 128) 
					{
						len++;
						j++;
					}
					else
					{
						len += 2;
						j += 2;
					}
				}
			}
			j = 0;
			
			if(mode == 1)
			{
				x -= len*8-1;
			}else if(mode == 2)
			{
				x -= len*4;
			}
			while(ch[j] != '\0')
			{
				if(ch[j] == 0x0D)
				{
					if(ch[++j] == 0x0A)
					{
						x = x_initial;
						y +=2;
						j++;
					}
				}
				else
				{
					if(ch[j] < 128)
					{
						c = ch[j] - 32;
						
						if((x+8) > 128)
						{
							x = 0;
							y +=2;
						}
						if(y > 6)
						{
							OLED_CLS();
							OLED_ShowStr(0, 0, "String text out of page!", LEFT, 8*16, NORMAL);
							break;
						}
						OLED_SetPos(x,y);
						for(i=0;i<8;i++)
						{
							WriteDat(F8X16[c*16+i], type);
							G_X_Pointer++;
						}
						OLED_SetPos(x,y+1);
						for(i=0;i<8;i++)
						{
							WriteDat(F8X16[c*16+i+8], type);
							G_X_Pointer++;
						}
						x += 8;
						j++;
					}
#if OLED_DISPLAY_TYPE
					else
					{
						unsigned short index = 0;
						
						index = ch[j]<<8 |  ch[j+1];
						UG_ShowCN(x, y, index, type);
						
						x += 16;
						j += 2;
					}
#endif
				}
			}
			break;
		}
		default:
			OLED_ShowStr(x, y, "String textsize is wrong!", LEFT, 6*8, NORMAL);
		break;
	}
}

/**
  * @brief Display integer
  * This function has the following characteristics:
  * 1.Display positive and negative integers
  * 2.Align data left or right
  * @param x [0-6 / 0-7] Coordinate of diagonal (starting point) x (0-127)
  * @param y [0-6 / 0-7] Coordinate of diagonal (starting point) y 
  * @param number [-9999 9999 - 9999 9999] Integer bit to display
  * @param mode [LEFT / RIGHT] Align mode 
  * @param TextSize [6*8 / 8*16] Display font size
  * @return void
  */
void OLED_ShowInt(u8 x, u8 y,int number, OLED_ALIGNMENT mode, u8 TextSize, OLED_DISPLAY type)
{
	u8 c[2]={0}, digit=0;
	u8 change[11];	//Defined as 11 spill prevention,u32:0x0000-0xffff
	u8 i=0;
	
	/*Negative sign needs to be added before negative number*/
	if(number<0)
	{
		number=abs(number);
		change[0]=45;
	}else
	{
		change[0]=0;
	}
	
	/*Absolute value input data digit statistics*/
	do{
		change[++i]=number%10+48;
		number/=10;
	}while(number);
	digit=i;
	
	if(change[0]==45) i++; //If it is a negative number, it needs to move one bit to the right

	if(TextSize == 6*8)
	{
		if(mode == 0)
		{
			if(x+i*6 > 128)
			{
				OLED_CLS();
				OLED_ShowStr(0, 0, "Integer text out of page!", LEFT, TextSize, NORMAL);
				return;
			}
			if(change[0]==45)
			{
				c[0]=change[0];
				OLED_ShowStr(x, y, c, LEFT, TextSize, type);
				x += 6;
			}
		}else if(mode == 1)
		{
			if(x < i*6)
			{
				OLED_CLS();
				OLED_ShowStr(0, 0, "Integer text out of page!", LEFT, TextSize, NORMAL);
				return;
			}else
			{
				x -= digit*6-1;
				if(change[0]==45)
				{
					c[0]=change[0];
					OLED_ShowStr(x-6, y, c, LEFT, TextSize, type);
				}
			}
		}else if(mode == 2)
		{
			x -= digit*3;
			if(change[0]==45)
			{
				c[0]=change[0];
				OLED_ShowStr(x-6, y, c, LEFT, TextSize, type);
			}
		}
	}
	else if(TextSize == 8*16)
	{
		if(mode == 0)
		{
			if(x+i*8 > 128)
			{
				OLED_CLS();
				OLED_ShowStr(0, 0, "Integer text out of page!", LEFT, TextSize, NORMAL);
				return;
			}
			if(change[0]==45)
			{
				c[0]=change[0];
				OLED_ShowStr(x, y, c, LEFT, TextSize, type);
				x += 8;
			}
		}else if(mode == 1)
		{
			if(x < i*8)
			{
				OLED_CLS();
				OLED_ShowStr(0, 0, "Integer text out of page!", LEFT, TextSize, NORMAL);
				return;
			}else
			{
				x -= digit*8-1;
				if(change[0]==45)
				{
					c[0]=change[0];
					OLED_ShowStr(x-8, y, c, LEFT, TextSize, type);
				}
			}
		}else if(mode == 2)
		{
			x -= digit*4;
			if(change[0]==45)
			{
				c[0]=change[0];
				OLED_ShowStr(x-6, y, c, LEFT, TextSize, type);
			}
		}
	}
	
	/*Cycle display and shift*/
	while(digit)
	{
		c[0]=change[digit];
		digit--;
		
		OLED_ShowStr(x, y, c, LEFT, TextSize, type);

		if(TextSize==6*8)
		{
			x += 6;
		}
		else
		{
			x += 8;
		}
	}
}

void OLED_ShowStrInt(u8 x, u8 y, u8 ch[], int number, OLED_ALIGNMENT mode, u8 TextSize, OLED_DISPLAY type)
{
	u8 len=0, len_ch, digit=0, number_change;
	u8 str[22] = {0};
	
	strcpy((char*)str, (char*)ch);
	
	str[strlen((const char*)ch)] = '=';
	
	if(number<0)
	{
		len++;
	}
	
	number_change = abs(number);
	
	while(number_change)
	{
		number_change /= 10;
		digit++;
	}
	
	len_ch = strlen((const char*)str);
	
	len = len_ch+digit;
	
	if(TextSize == 6*8)
	{
		len_ch *= 6;
		digit *= 6;
		len *= 6;
	}
	else if(TextSize == 8*16)
	{
		len_ch *= 8;
		digit *= 8;
		len *= 8;
	}
	
	if(mode == 0)
	{
		OLED_ShowStr(x, y, str, mode, TextSize, type);
		OLED_ShowInt(x+len_ch, y, number, mode, TextSize, type);
	}
	else if(mode == 1)
	{
//		OLED_ShowStr(x, y, ch, mode, TextSize, type);
//		OLED_ShowInt(x+len_ch, y, number, mode, TextSize, type);
	}
	else if(mode == 2)
	{
		OLED_ShowStr(x-digit, y, ch, mode, TextSize, type);
		OLED_ShowInt(x, y, number, mode, TextSize, type);
	}
}

/**
  * @brief Display single and double precision floating-point numbers (remove the invalid 0 of integer part)
  * This function has the following characteristics:
  * 1.Display positive and negative single and double precision floating-point numbers
  * 2.Display floating-point numbers in alignment
  * 3.Can intercept floating-point numbers
  * @param x [0-127] Coordinate of diagonal (starting point) x
  * @param y [0-6 / 0-7] Coordinate of diagonal (starting point) y 
  * @param dat [0-8] Integer bit display length double up to 9 bits,single precision floating point number needs to test precision
  * @param pointnum [0-6] Display length of decimal places double up to 6 bits，,single precision floating point number needs to test precision
  * @param TextSize [6*8 / 8*16] Display font size 
  * @return void
  * @note
  * 	When the single precision floating-point number is displayed,
  * 	the precision will be lost. Be careful not to exceed the display range,
  * 	or the data interception function will be executed
  */
void OLED_ShowFloat(u16 x, u16 y, double dat, u8 num, u8 pointnum, u8 TextSize)
{
    u8	length;
	u8	buff[18]={0};
	char	BuffPre[18]={0};
	short int start;
	u8   end=0, point=0, add=0;

	/*Control data capture*/
	if(6<pointnum)  pointnum = 6;
    if(9<num)	num = 9;
    
	/*A positive number requires a space before the string*/
	if(dat<0)
		length = sprintf( &BuffPre[0],"%f",dat);
	else
	{
		BuffPre[0] = ' ';
		length = sprintf( &BuffPre[1],"%f",dat)+1;
	}
	
    point = length - 7;         //Calculate decimal point position
    start = point - num - 1;    //Calculation start bit
    end = point + pointnum + 1; //Calculation end bit
	
	/*Fill in spaces when integer bits are not enough*/
    while(0>start)
    {
        buff[add] = ' ';
		add++;
		start++;
		point++;
		end++;
    }
	
	if(start>0)
	{
		start++;
		end-=point-num;
	}
	
	str_cpy(&buff[add], &BuffPre[start]); //Concatenate strings after spaces

	buff[end] = '\0'; //Need to add '\0' at the end when intercepting string
    
    OLED_ShowStr(x, y, (u8 *)buff, LEFT, TextSize, NORMAL);	
}

/**
  * @brief Display Chinese characters, 16 * 16 dot matrix
  * @param x [0-127] Coordinate of diagonal (starting point) x
  * @param y [0-6 / 0-7] Coordinate of diagonal (starting point) y 
  * @param N Chinese character index
  * @return void
  */
void OLED_ShowCN(u8 x, u8 y, u8 N)
{
	u8 wm=0;
	unsigned int  adder=32*N;
	OLED_SetPos(x , y);
	for(wm = 0;wm < 16;wm++)
	{
		WriteDat(F16x16[adder], 0);
		adder += 1;
	}
	OLED_SetPos(x,y + 1);
	for(wm = 0;wm < 16;wm++)
	{
		WriteDat(F16x16[adder], 0);
		adder += 1;
	}
}

/**
  * @brief Show BMP bitmap
  * @param x0 Coordinate of diagonal (starting point) x
  * @param y0 Coordinate of diagonal (starting point) y
  * @param x1 Coordinate of diagonal (end point) x
  * @param y1 Coordinate of diagonal (end point) y
  * @param BMP Image address
  * @return void
  * @note
  * 	Using image2lcd v3.2 software to take the mold
  */
void OLED_ShowBMP(u8 x0,u8 y0,u8 x1,u8 y1,u8 BMP[])
{
	unsigned int j=0;
	u8 x,y;

	if(y1%8==0)
		y = y1/8;
	else
		y = y1/8 + 1;
	for(y=y0;y<y1;y++)
	{
		OLED_SetPos(x0,y);
    for(x=x0;x<x1;x++)
		{
			WriteDat(BMP[j++], 0);
		}
	}
}

void OLED_DrawPicture(u8 x, u8 y, u8 width, u8 length, u8 bmp[])
{      			    
	u8 i, j, k, y0;
	
	x -= width/2;
	y -= length/2;
	
	if(length%8==0)
		y0 = length/8;
	else
		y0 = length/8 + 1;
	
	for(i=0; i<y0; i++)
	{
		for(j=0; j<width; j++)
		{
			for(k=0;  k<8; k++)
			{
				//OLED_DrawPoint(x+j , y+i*8+k, bmp[i*width+j]&1<<k);
				if(bmp[i*width+j]&1<<k) OLED_DrawPoint(x+j , y+i*8+k, 1);
			}
		}
	}
}

/**
  * @brief 256 gray to binary BMP
  * @param high Image height
  * @param width Image width
  * @param p Image address
  * @param value Binary threshold
  * @return void
  */
void OLED_ShowBinary(u16 high, u16 width, u8 *p, u8 value)
{
    u16 i,j;
    u16 temp,temp1;
    u8 dat;
	
    temp1 = high%8;
    if(temp1 == 0) temp = high/8;
    else           temp = high/8+1;
    
    for(i=0; i<temp; i++)
    {
        OLED_SetPos(0,i);
        for(j=0; j<width; j++)
        {
            dat = 0;
            if( i<(temp-1) || !temp1 || temp1>=1)dat |= (*(p+i*8*width+j+width*0) > value? 1: 0)<<0;
            if( i<(temp-1) || !temp1 || temp1>=2)dat |= (*(p+i*8*width+j+width*1) > value? 1: 0)<<1;
            if( i<(temp-1) || !temp1 || temp1>=3)dat |= (*(p+i*8*width+j+width*2) > value? 1: 0)<<2;
            if( i<(temp-1) || !temp1 || temp1>=4)dat |= (*(p+i*8*width+j+width*3) > value? 1: 0)<<3;
            if( i<(temp-1) || !temp1 || temp1>=5)dat |= (*(p+i*8*width+j+width*4) > value? 1: 0)<<4;
            if( i<(temp-1) || !temp1 || temp1>=6)dat |= (*(p+i*8*width+j+width*5) > value? 1: 0)<<5;
            if( i<(temp-1) || !temp1 || temp1>=7)dat |= (*(p+i*8*width+j+width*6) > value? 1: 0)<<6;
            if( i<(temp-1) || !temp1 || temp1>=8)dat |= (*(p+i*8*width+j+width*7) > value? 1: 0)<<7;
           
            WriteDat(dat, 0);
        }
    }
}
